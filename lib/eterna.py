import platform
import subprocess as sp
import re
import pandas as pd
from datetime import timedelta


def predict() -> None:
    """
    Starts the Eterna prediction software.

    The function first detects the Operating System, then starts the prediction
    software using the correct executable name.

    Parameters
    ----------
    None

    Returns
    -------
    None
    """
    _os = platform.system()
    if 'Linux' in _os:
        with sp.Popen(['wine', r'./predict.exe']) as _process:
            _process.wait()
    elif 'Windows' in _os:
        with sp.Popen(['cmd','/c', r'.\predict']) as _process:
            _process.wait()
    else:
        exit(-1)

def update_project(_projectpath, _sitename) -> None:
    """
    Update the project file with the name of the site that you want to predict.

    Parameters
    ----------
    _projectpath : str
        The path of the project file.
    _sitename : str
        The name of the site that you want to predict.
    """
    with open (_projectpath, 'w', encoding='utf-8') as f:
        line = f"{_sitename}    "
        f.write(line)
    f.close()

def update_site_ini(_site_ini, _startdate, _enddate, _samplerate) -> None:
    """
    Update the site ini file with the params that you set as arguments.

    Parameters
    ----------
    _site_ini : str
        The path of the site ini file.
    _startdate : datetime
        The initial datetime of the prediction.
    _enddate : datetime
        The end datetime of the prediction.
        The sampling rate in seconds.

    Returns
    -------
    None
    """

    with open(_site_ini, 'r', encoding='utf-8') as f:
        _lines = f.readlines()
        for i, line in enumerate(_lines):
            if("SAMPLERATE" in line.strip()):
                _lines[i] = f"SAMPLERATE=     {_samplerate}          # sampling interval in seconds\n"
            if("INITIALEPO" in line.strip()):
                _lines[i] = f"INITIALEPO= {_startdate.year}   {_startdate.month}  {_startdate.day}  # initia\n"
            if "PREDICSPAN" in line.strip():
                _difference = _enddate - _startdate
                _hours = (_difference.days + 1) * 24
                _lines[i] = f"PREDICSPAN=      {_hours}       # prediction time span in hours for PREDICT\n"
    f.close()

    # write the update file
    with open(_site_ini, 'w', encoding='utf-8') as f:
        f.writelines(_lines)
    f.close()

def parse_prediction(_input_path, _output_path, _samplerate=1) -> None:
    """
    Parse the prediction file generated by the Eterna prediction software and save it in a csv file.

    Parameters
    ----------
    _input_path : str
        The path of the file generated by the Eterna prediction software.
    _output_path : str
        The path of the output csv file.
    _samplerate : int
        The sampling interval in seconds. Default is 1 second.

    Returns
    -------
    None
    """
    with open(_input_path, 'r', encoding='utf-8') as f:
        _lines = f.readlines()
        _start = 0
        _end = len(_lines) - 2
        for i, line in enumerate(_lines):
            if("77777777" in line.strip()):
                _start = i + 1
    f.close()

    # generate and array of arrays that contains for each row the splitted columns
    _splitted = [re.split(r'\s+', item.strip()) for item in _lines[_start:_end]]

    columns = ['datetime', 'time', 'tide'] # columns of the dataframe
    df = pd.DataFrame(_splitted, columns=columns) # dataframe of the prediction
    df['datetime'] = pd.to_datetime(df['datetime'], format='%Y%m%d') # convert date to datetime

    _initial_datetime = df['datetime'].iloc[0]
    _delta_samplerate = timedelta(seconds=_samplerate)

    df['datetime'] = _initial_datetime + df.index * _delta_samplerate
    df['tide'] = df['tide'].astype(float)
    df['tide'] = df['tide'] / 10
    df = df.drop(columns=['time']) # delete the time counter column
    df.to_csv(_output_path, index=False) # write the dataframe on the output csv file